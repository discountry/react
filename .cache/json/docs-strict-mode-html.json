{"data":{"markdownRemark":{"html":"<h2 id=\"严格模式\"><a href=\"#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>严格模式</h2>\n<p><code class=\"gatsby-code-text\">StrictMode</code>是一个用以标记出应用中潜在问题的工具。就像<code class=\"gatsby-code-text\">Fragment</code>，<code class=\"gatsby-code-text\">StrictMode</code>不会渲染任何真实的UI。它为其后代元素触发额外的检查和警告。</p>\n<blockquote>\n<p>注意:\n严格模式检查只在开发模式下运行，不会与生产模式冲突。</p>\n</blockquote>\n<p>你可以在应用的任何地方启用严格模式。例如：</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">ExampleApplication</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Header</span> <span class=\"token punctuation\">/></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>React.StrictMode</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n          <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ComponentOne</span> <span class=\"token punctuation\">/></span></span>\n          <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ComponentTwo</span> <span class=\"token punctuation\">/></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>React.StrictMode</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Footer</span> <span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n      </div>\n<p>在上面的例子中，不会对组件<code class=\"gatsby-code-text\">Header</code>、<code class=\"gatsby-code-text\">Footer</code>进行strict mode检查。然而<code class=\"gatsby-code-text\">ComponentOne</code>、<code class=\"gatsby-code-text\">ComponentTwo</code>以及它们所有的后代将被检查。</p>\n<p><code class=\"gatsby-code-text\">StrictMode</code>目前有助于：</p>\n<ul>\n<li><a href=\"#%E8%AF%86%E5%88%AB%E5%85%B7%E6%9C%89%E4%B8%8D%E5%AE%89%E5%85%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%BB%84%E4%BB%B6\">识别具有不安全生命周期的组件</a></li>\n<li><a href=\"#%E6%9C%89%E5%85%B3%E6%97%A7%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2ref%E7%94%A8%E6%B3%95%E7%9A%84%E8%AD%A6%E5%91%8A\">有关旧式字符串ref用法的警告</a></li>\n<li><a href=\"#%E6%A3%80%E6%B5%8B%E6%84%8F%E5%A4%96%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8\">检测意外的副作用</a></li>\n</ul>\n<h3 id=\"识别具有不安全生命周期的组件\"><a href=\"#%E8%AF%86%E5%88%AB%E5%85%B7%E6%9C%89%E4%B8%8D%E5%AE%89%E5%85%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%BB%84%E4%BB%B6\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>识别具有不安全生命周期的组件</h3>\n<p>如同在<a href=\"https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html\">博客</a>中阐明的，在异步React应用中使用某些老式的生命周期方法不安全。但是, 如果应用程序使用第三方库, 则很难确保不使用这些生命周期方法。幸运的是, 严格的模式可以帮助解决这个问题!</p>\n<p>当启用严格模式, React将编译一个所有使用不安全生命周期组件的列表，并打印一条关于这些组件的警告信息，就像：</p>\n<p><img src=\"https://reactjs.org/static/strict-mode-unsafe-lifecycles-warning-e4fdbff774b356881123e69ad88eda88-2535d.png\"></p>\n<h3 id=\"有关旧式字符串ref用法的警告\"><a href=\"#%E6%9C%89%E5%85%B3%E6%97%A7%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2ref%E7%94%A8%E6%B3%95%E7%9A%84%E8%AD%A6%E5%91%8A\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>有关旧式字符串ref用法的警告</h3>\n<p>以前，React提供了2种方法管理ref：旧式的字符串ref API和回调API。虽然字符串ref API更加方便，但它有些许<a href=\"https://github.com/facebook/react/issues/1373\">缺点</a>，因此我们的正式建议是<a href=\"https://doc.react-china.org/docs/refs-and-the-dom.html#%E6%97%A7%E7%89%88-api%EF%BC%9Astring-%E7%B1%BB%E5%9E%8B%E7%9A%84-refs\">改用回调方式</a></p>\n<p>React 16.3新增了第三种方式, 它提供了字符串 ref 的方便性, 而没有任何缺点:</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"gatsby-code-js\"><code class=\"gatsby-code-js\">class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.inputRef = React.createRef();\n  }\n\n  render() {\n    return &lt;input type=&quot;text&quot; ref={this.inputRef} /&gt;;\n  }\n\n  componentDidMount() {\n    this.inputRef.current.focus();\n  }\n}</code></pre>\n      </div>\n<p>由于新增的对象式refs很大程度上作为字符串ref的替换，因此strict mode现在对字符串ref的用法发出警告。</p>\n<blockquote>\n<p>注意：\n除了新的createRef API，回调ref将被继续支持。您不需要在组件中替换回调ref。它们稍微灵活一些, 因此它们将保持为高级功能。</p>\n</blockquote>\n<p><a href=\"https://doc.react-china.org/docs/refs-and-the-dom.html\">学习更多有关createRef API内容</a></p>\n<h3 id=\"检测意外的副作用\"><a href=\"#%E6%A3%80%E6%B5%8B%E6%84%8F%E5%A4%96%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>检测意外的副作用</h3>\n<p>理论上，React在两个阶段起作用:</p>\n<ul>\n<li><strong>渲染</strong>阶段决定了需要对 DOM 进行哪些更改。在此阶段, React调用<code class=\"gatsby-code-text\">render</code>(方法), 然后将结果与上一次渲染进行比较。</li>\n<li><strong>提交</strong>阶段是React执行任何更改的阶段。(在React DOM中, 指React插入、更新和删除 dom 节点）。在此阶段React也调用生命周期, 如 <code class=\"gatsby-code-text\">componentDidMount</code> 和 <code class=\"gatsby-code-text\">componentDidUpdate</code> 。</li>\n</ul>\n<p>提交阶段通常很快，但是渲染可能很慢。因此, 即将出现的异步模式 (默认情况下尚未启用) 将呈现工作分解为片断, 暂停和恢复工作以避免阻止浏览器。这意味着在提交之前, 反应可能不止一次地调用渲染阶段生命周期, 或者它可以在不提交的情况下调用它们 (因为错误或更高的优先级中断)。</p>\n<p>渲染阶段的生命周期包括以下class component方法：</p>\n<ul>\n<li><code class=\"gatsby-code-text\">constructor</code></li>\n<li><code class=\"gatsby-code-text\">componentWillMount</code></li>\n<li><code class=\"gatsby-code-text\">componentWillReceiveProps</code></li>\n<li><code class=\"gatsby-code-text\">componentWillUpdate</code></li>\n<li><code class=\"gatsby-code-text\">getDerivedStateFromProps</code></li>\n<li><code class=\"gatsby-code-text\">shouldComponentUpdate</code></li>\n<li><code class=\"gatsby-code-text\">render</code></li>\n<li><code class=\"gatsby-code-text\">setState</code> 更新函数 (第一个形参）</li>\n</ul>\n<p>因为以上方法可能不止一次被调用，所以它们中不包含副作用尤为重要。忽略此规则可能会导致各种问题, 包括内存泄漏和无效的应用程序状态。不幸的是, 很难发现这些问题, 因为它们通常都是<a href=\"https://en.wikipedia.org/wiki/Deterministic_algorithm\">不确定的</a>。</p>\n<p>严格模式不能自动检测到你的副作用, 但它可以帮助你发现它们, 使其更具确定性。这是通过有意地双调用以下方法来完成的:</p>\n<ul>\n<li>Class component <code class=\"gatsby-code-text\">constructor</code></li>\n<li><code class=\"gatsby-code-text\">render</code></li>\n<li><code class=\"gatsby-code-text\">setState</code> 更新函数 (第一个形参）</li>\n<li>static <code class=\"gatsby-code-text\">getDerivedStateFromProps</code></li>\n</ul>\n<blockquote>\n<p>注意：\n只在开发模式生效。生产模式下生命周期不会被双调用。</p>\n</blockquote>\n<p>举个例子，考虑以下代码：</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"gatsby-code-js\"><code class=\"gatsby-code-js\">class TopLevelRoute extends React.Component {\n  constructor(props) {\n    super(props);\n\n    SharedApplicationState.recordEvent(&#39;ExampleComponent&#39;);\n  }\n}</code></pre>\n      </div>\n<p>乍一看, 这段代码似乎没有问题。但是如果 <code class=\"gatsby-code-text\">SharedApplicationState.recordEvent</code> 不是<a href=\"https://en.wikipedia.org/wiki/Idempotence#Computer_science_meaning\">幂等</a>, 那么多次实例化此组件可能会导致无效的应用程序状态。这种微妙的 bug 可能不会在开发过程中显现出来, 或者它可能会不一致, 因此被忽略。</p>\n<p>通过有意的双调用方法 (如组件构造函数), 严格模式使得这样的行为更容易被发现。</p>","frontmatter":{"title":"Strict Mode","next":null,"prev":null},"fields":{"path":"docs/strict-mode.md","slug":"docs/strict-mode.html"}}},"pathContext":{"slug":"docs/strict-mode.html"}}