{"version":3,"sources":["webpack:///path---index-0fdd23e5f5a75694a064.js","webpack:///./.cache/json/index.json"],"names":["webpackJsonp","946","module","exports","data","code","edges","node","id","internal","contentDigest","examples","fields","slug","frontmatter","title","html","marketing","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,QAAUC,MAAQC,GAAA,qCAAAC,UAAsDC,cAAA,82BAAk4BH,MAAQC,GAAA,qBAAAC,UAAsCC,cAAA,sPAA0QH,MAAQC,GAAA,uBAAAC,UAAwCC,cAAA,8jBAAglBH,MAAQC,GAAA,iBAAAC,UAAkCC,cAAA,o0CAAm1CC,UAAaL,QAAUC,MAAQK,QAAUC,KAAA,0CAAgDC,aAAgBC,MAAA,MAAaC,KAAA,4jBAA4kBT,MAAQK,QAAUC,KAAA,4CAAkDC,aAAgBC,MAAA,SAAgBC,KAAA,gPAA8PT,MAAQK,QAAUC,KAAA,sCAA4CC,aAAgBC,MAAA,MAAaC,KAAA,uPAAqQT,MAAQK,QAAUC,KAAA,0DAAgEC,aAAgBC,MAAA,cAAqBC,KAAA,uLAAgMC,WAAcX,QAAUC,MAAQO,aAAeC,MAAA,OAAcC,KAAA,mHAA2HT,MAAQO,aAAeC,MAAA,OAAcC,KAAA,sGAA8GT,MAAQO,aAAeC,MAAA,aAAoBC,KAAA,qJAA8JE","file":"path---index-0fdd23e5f5a75694a064.js","sourcesContent":["webpackJsonp([142629428675168],{\n\n/***/ 946:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"code\":{\"edges\":[{\"node\":{\"id\":\"a-component-using-external-plugins\",\"internal\":{\"contentDigest\":\"\\\"class MarkdownEditor extends React.Component {\\\\n  constructor(props) {\\\\n    super(props);\\\\n    this.handleChange = this.handleChange.bind(this);\\\\n    this.state = { value: 'Type some *markdown* here!' };\\\\n  }\\\\n\\\\n  handleChange(e) {\\\\n    this.setState({ value: e.target.value });\\\\n  }\\\\n\\\\n  getRawMarkup() {\\\\n    const md = new Remarkable();\\\\n    return { __html: md.render(this.state.value) };\\\\n  }\\\\n\\\\n  render() {\\\\n    return (\\\\n      <div className=\\\\\\\"MarkdownEditor\\\\\\\">\\\\n        <h3>Input</h3>\\\\n        <textarea\\\\n          onChange={this.handleChange}\\\\n          defaultValue={this.state.value}\\\\n        />\\\\n        <h3>Output</h3>\\\\n        <div\\\\n          className=\\\\\\\"content\\\\\\\"\\\\n          dangerouslySetInnerHTML={this.getRawMarkup()}\\\\n        />\\\\n      </div>\\\\n    );\\\\n  }\\\\n}\\\\n\\\\nReactDOM.render(<MarkdownEditor />, mountNode);\\\"\"}}},{\"node\":{\"id\":\"a-simple-component\",\"internal\":{\"contentDigest\":\"\\\"class HelloMessage extends React.Component {\\\\n  render() {\\\\n    return (\\\\n      <div>\\\\n        Hello {this.props.name}\\\\n      </div>\\\\n    );\\\\n  }\\\\n}\\\\n\\\\nReactDOM.render(\\\\n  <HelloMessage name=\\\\\\\"Taylor\\\\\\\" />,\\\\n  mountNode\\\\n);\\\"\"}}},{\"node\":{\"id\":\"a-stateful-component\",\"internal\":{\"contentDigest\":\"\\\"class Timer extends React.Component {\\\\n  constructor(props) {\\\\n    super(props);\\\\n    this.state = { seconds: 0 };\\\\n  }\\\\n\\\\n  tick() {\\\\n    this.setState(prevState => ({\\\\n      seconds: prevState.seconds + 1\\\\n    }));\\\\n  }\\\\n\\\\n  componentDidMount() {\\\\n    this.interval = setInterval(() => this.tick(), 1000);\\\\n  }\\\\n\\\\n  componentWillUnmount() {\\\\n    clearInterval(this.interval);\\\\n  }\\\\n\\\\n  render() {\\\\n    return (\\\\n      <div>\\\\n        Seconds: {this.state.seconds}\\\\n      </div>\\\\n    );\\\\n  }\\\\n}\\\\n\\\\nReactDOM.render(<Timer />, mountNode);\\\"\"}}},{\"node\":{\"id\":\"an-application\",\"internal\":{\"contentDigest\":\"\\\"class TodoApp extends React.Component {\\\\n  constructor(props) {\\\\n    super(props);\\\\n    this.state = { items: [], text: '' };\\\\n    this.handleChange = this.handleChange.bind(this);\\\\n    this.handleSubmit = this.handleSubmit.bind(this);\\\\n  }\\\\n\\\\n  render() {\\\\n    return (\\\\n      <div>\\\\n        <h3>TODO</h3>\\\\n        <TodoList items={this.state.items} />\\\\n        <form onSubmit={this.handleSubmit}>\\\\n          <input\\\\n            onChange={this.handleChange}\\\\n            value={this.state.text}\\\\n          />\\\\n          <button>\\\\n            Add #{this.state.items.length + 1}\\\\n          </button>\\\\n        </form>\\\\n      </div>\\\\n    );\\\\n  }\\\\n\\\\n  handleChange(e) {\\\\n    this.setState({ text: e.target.value });\\\\n  }\\\\n\\\\n  handleSubmit(e) {\\\\n    e.preventDefault();\\\\n    if (!this.state.text.length) {\\\\n      return;\\\\n    }\\\\n    const newItem = {\\\\n      text: this.state.text,\\\\n      id: Date.now()\\\\n    };\\\\n    this.setState(prevState => ({\\\\n      items: prevState.items.concat(newItem),\\\\n      text: ''\\\\n    }));\\\\n  }\\\\n}\\\\n\\\\nclass TodoList extends React.Component {\\\\n  render() {\\\\n    return (\\\\n      <ul>\\\\n        {this.props.items.map(item => (\\\\n          <li key={item.id}>{item.text}</li>\\\\n        ))}\\\\n      </ul>\\\\n    );\\\\n  }\\\\n}\\\\n\\\\nReactDOM.render(<TodoApp />, mountNode);\\\"\"}}}]},\"examples\":{\"edges\":[{\"node\":{\"fields\":{\"slug\":\"/home/examples/a-simple-component.html\"},\"frontmatter\":{\"title\":\"组件\"},\"html\":\"<p>React 组件使用一个名为 <code class=\\\"gatsby-code-text\\\">render()</code> 的方法， 接收数据作为输入，输出页面中对应展示的内容。 下面这个示例中类似XML的写法被称为JSX. 输入的数据通过 <code class=\\\"gatsby-code-text\\\">this.props</code> 传入 <code class=\\\"gatsby-code-text\\\">render()</code> 方法。</p>\\n<p><strong>使用 React 的时候也可以不使用 JSX 语法</strong> 你可以在 <a href=\\\"https://babeljs.io/repl/#?presets=react&#x26;code_lz=MYewdgzgLgBApgGzgWzmWBeGAeAFgRgD4AJRBEAGhgHcQAnBAEwEJsB6AwgbgChRJY_KAEMAlmDh0YWRiGABXVOgB0AczhQAokiVQAQgE8AkowAUPGDADkdECChWeASl4AlOMOBQAIgHkAssp0aIySpogoaFBUQmISdC48QA\\\">Babel REPL</a> 查看 JSX 是如何被渲染成原生 JavaScript 代码的。</p>\"}},{\"node\":{\"fields\":{\"slug\":\"/home/examples/a-stateful-component.html\"},\"frontmatter\":{\"title\":\"有状态组件\"},\"html\":\"<p>除了使用外部传入的数据以外 (通过 <code class=\\\"gatsby-code-text\\\">this.props</code> 访问传入数据), 组件还可以拥有其内部的状态数据 (通过 <code class=\\\"gatsby-code-text\\\">this.state</code> 访问状态数据)。 当组件的状态数据改变时， 组件会调用 <code class=\\\"gatsby-code-text\\\">render()</code> 方法重新渲染。</p>\"}},{\"node\":{\"fields\":{\"slug\":\"/home/examples/an-application.html\"},\"frontmatter\":{\"title\":\"应用\"},\"html\":\"<p>使用 <code class=\\\"gatsby-code-text\\\">props</code> 和 <code class=\\\"gatsby-code-text\\\">state</code>, 我们可以创建一个简易的 Todo 应用。 下面这个示例中，我们使用 <code class=\\\"gatsby-code-text\\\">state</code> 来保存现有的待办事项列表及用户的输入。 与此同时，我们也使用了内联的方法添加了事件处理函数，它们将通过事件代理被收集和调用。</p>\"}},{\"node\":{\"fields\":{\"slug\":\"/home/examples/a-component-using-external-plugins.html\"},\"frontmatter\":{\"title\":\"在组件中使用第三方库\"},\"html\":\"<p>React 的使用非常灵活，并且提供了可以调用其他第三方框架或库的接口。下面这个示例就使用了一个用来渲染 markdown 语法，名为 <strong>remarkable</strong> 的库。它可以实时转换渲染 <code class=\\\"gatsby-code-text\\\">&lt;textarea&gt;</code> 里的内容。</p>\"}}]},\"marketing\":{\"edges\":[{\"node\":{\"frontmatter\":{\"title\":\"声明式\"},\"html\":\"<p>React 可以非常轻松地创建用户交互界面。为你应用的每一个状态设计简洁的视图，在数据改变时 React 也可以高效地更新渲染界面。</p>\\n<p>以声明式编写UI，可以让你的代码更加可靠，且方便调试。</p>\"}},{\"node\":{\"frontmatter\":{\"title\":\"组件化\"},\"html\":\"<p>创建好拥有各自状态的组件，再由组件构成更加复杂的界面。</p>\\n<p>无需再用模版代码，通过使用JavaScript编写的组件你可以更好地传递数据，将应用状态和DOM拆分开来。</p>\"}},{\"node\":{\"frontmatter\":{\"title\":\"一次学习，随处编写\"},\"html\":\"<p>无论你现在正在使用什么技术栈，你都可以随时引入 React 开发新特性。</p>\\n<p>React 也可以用作开发原生应用的框架 <a href=\\\"https://facebook.github.io/react-native/\\\">React Native</a>.</p>\"}}]}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---index-0fdd23e5f5a75694a064.js","module.exports = {\"data\":{\"code\":{\"edges\":[{\"node\":{\"id\":\"a-component-using-external-plugins\",\"internal\":{\"contentDigest\":\"\\\"class MarkdownEditor extends React.Component {\\\\n  constructor(props) {\\\\n    super(props);\\\\n    this.handleChange = this.handleChange.bind(this);\\\\n    this.state = { value: 'Type some *markdown* here!' };\\\\n  }\\\\n\\\\n  handleChange(e) {\\\\n    this.setState({ value: e.target.value });\\\\n  }\\\\n\\\\n  getRawMarkup() {\\\\n    const md = new Remarkable();\\\\n    return { __html: md.render(this.state.value) };\\\\n  }\\\\n\\\\n  render() {\\\\n    return (\\\\n      <div className=\\\\\\\"MarkdownEditor\\\\\\\">\\\\n        <h3>Input</h3>\\\\n        <textarea\\\\n          onChange={this.handleChange}\\\\n          defaultValue={this.state.value}\\\\n        />\\\\n        <h3>Output</h3>\\\\n        <div\\\\n          className=\\\\\\\"content\\\\\\\"\\\\n          dangerouslySetInnerHTML={this.getRawMarkup()}\\\\n        />\\\\n      </div>\\\\n    );\\\\n  }\\\\n}\\\\n\\\\nReactDOM.render(<MarkdownEditor />, mountNode);\\\"\"}}},{\"node\":{\"id\":\"a-simple-component\",\"internal\":{\"contentDigest\":\"\\\"class HelloMessage extends React.Component {\\\\n  render() {\\\\n    return (\\\\n      <div>\\\\n        Hello {this.props.name}\\\\n      </div>\\\\n    );\\\\n  }\\\\n}\\\\n\\\\nReactDOM.render(\\\\n  <HelloMessage name=\\\\\\\"Taylor\\\\\\\" />,\\\\n  mountNode\\\\n);\\\"\"}}},{\"node\":{\"id\":\"a-stateful-component\",\"internal\":{\"contentDigest\":\"\\\"class Timer extends React.Component {\\\\n  constructor(props) {\\\\n    super(props);\\\\n    this.state = { seconds: 0 };\\\\n  }\\\\n\\\\n  tick() {\\\\n    this.setState(prevState => ({\\\\n      seconds: prevState.seconds + 1\\\\n    }));\\\\n  }\\\\n\\\\n  componentDidMount() {\\\\n    this.interval = setInterval(() => this.tick(), 1000);\\\\n  }\\\\n\\\\n  componentWillUnmount() {\\\\n    clearInterval(this.interval);\\\\n  }\\\\n\\\\n  render() {\\\\n    return (\\\\n      <div>\\\\n        Seconds: {this.state.seconds}\\\\n      </div>\\\\n    );\\\\n  }\\\\n}\\\\n\\\\nReactDOM.render(<Timer />, mountNode);\\\"\"}}},{\"node\":{\"id\":\"an-application\",\"internal\":{\"contentDigest\":\"\\\"class TodoApp extends React.Component {\\\\n  constructor(props) {\\\\n    super(props);\\\\n    this.state = { items: [], text: '' };\\\\n    this.handleChange = this.handleChange.bind(this);\\\\n    this.handleSubmit = this.handleSubmit.bind(this);\\\\n  }\\\\n\\\\n  render() {\\\\n    return (\\\\n      <div>\\\\n        <h3>TODO</h3>\\\\n        <TodoList items={this.state.items} />\\\\n        <form onSubmit={this.handleSubmit}>\\\\n          <input\\\\n            onChange={this.handleChange}\\\\n            value={this.state.text}\\\\n          />\\\\n          <button>\\\\n            Add #{this.state.items.length + 1}\\\\n          </button>\\\\n        </form>\\\\n      </div>\\\\n    );\\\\n  }\\\\n\\\\n  handleChange(e) {\\\\n    this.setState({ text: e.target.value });\\\\n  }\\\\n\\\\n  handleSubmit(e) {\\\\n    e.preventDefault();\\\\n    if (!this.state.text.length) {\\\\n      return;\\\\n    }\\\\n    const newItem = {\\\\n      text: this.state.text,\\\\n      id: Date.now()\\\\n    };\\\\n    this.setState(prevState => ({\\\\n      items: prevState.items.concat(newItem),\\\\n      text: ''\\\\n    }));\\\\n  }\\\\n}\\\\n\\\\nclass TodoList extends React.Component {\\\\n  render() {\\\\n    return (\\\\n      <ul>\\\\n        {this.props.items.map(item => (\\\\n          <li key={item.id}>{item.text}</li>\\\\n        ))}\\\\n      </ul>\\\\n    );\\\\n  }\\\\n}\\\\n\\\\nReactDOM.render(<TodoApp />, mountNode);\\\"\"}}}]},\"examples\":{\"edges\":[{\"node\":{\"fields\":{\"slug\":\"/home/examples/a-simple-component.html\"},\"frontmatter\":{\"title\":\"组件\"},\"html\":\"<p>React 组件使用一个名为 <code class=\\\"gatsby-code-text\\\">render()</code> 的方法， 接收数据作为输入，输出页面中对应展示的内容。 下面这个示例中类似XML的写法被称为JSX. 输入的数据通过 <code class=\\\"gatsby-code-text\\\">this.props</code> 传入 <code class=\\\"gatsby-code-text\\\">render()</code> 方法。</p>\\n<p><strong>使用 React 的时候也可以不使用 JSX 语法</strong> 你可以在 <a href=\\\"https://babeljs.io/repl/#?presets=react&#x26;code_lz=MYewdgzgLgBApgGzgWzmWBeGAeAFgRgD4AJRBEAGhgHcQAnBAEwEJsB6AwgbgChRJY_KAEMAlmDh0YWRiGABXVOgB0AczhQAokiVQAQgE8AkowAUPGDADkdECChWeASl4AlOMOBQAIgHkAssp0aIySpogoaFBUQmISdC48QA\\\">Babel REPL</a> 查看 JSX 是如何被渲染成原生 JavaScript 代码的。</p>\"}},{\"node\":{\"fields\":{\"slug\":\"/home/examples/a-stateful-component.html\"},\"frontmatter\":{\"title\":\"有状态组件\"},\"html\":\"<p>除了使用外部传入的数据以外 (通过 <code class=\\\"gatsby-code-text\\\">this.props</code> 访问传入数据), 组件还可以拥有其内部的状态数据 (通过 <code class=\\\"gatsby-code-text\\\">this.state</code> 访问状态数据)。 当组件的状态数据改变时， 组件会调用 <code class=\\\"gatsby-code-text\\\">render()</code> 方法重新渲染。</p>\"}},{\"node\":{\"fields\":{\"slug\":\"/home/examples/an-application.html\"},\"frontmatter\":{\"title\":\"应用\"},\"html\":\"<p>使用 <code class=\\\"gatsby-code-text\\\">props</code> 和 <code class=\\\"gatsby-code-text\\\">state</code>, 我们可以创建一个简易的 Todo 应用。 下面这个示例中，我们使用 <code class=\\\"gatsby-code-text\\\">state</code> 来保存现有的待办事项列表及用户的输入。 与此同时，我们也使用了内联的方法添加了事件处理函数，它们将通过事件代理被收集和调用。</p>\"}},{\"node\":{\"fields\":{\"slug\":\"/home/examples/a-component-using-external-plugins.html\"},\"frontmatter\":{\"title\":\"在组件中使用第三方库\"},\"html\":\"<p>React 的使用非常灵活，并且提供了可以调用其他第三方框架或库的接口。下面这个示例就使用了一个用来渲染 markdown 语法，名为 <strong>remarkable</strong> 的库。它可以实时转换渲染 <code class=\\\"gatsby-code-text\\\">&lt;textarea&gt;</code> 里的内容。</p>\"}}]},\"marketing\":{\"edges\":[{\"node\":{\"frontmatter\":{\"title\":\"声明式\"},\"html\":\"<p>React 可以非常轻松地创建用户交互界面。为你应用的每一个状态设计简洁的视图，在数据改变时 React 也可以高效地更新渲染界面。</p>\\n<p>以声明式编写UI，可以让你的代码更加可靠，且方便调试。</p>\"}},{\"node\":{\"frontmatter\":{\"title\":\"组件化\"},\"html\":\"<p>创建好拥有各自状态的组件，再由组件构成更加复杂的界面。</p>\\n<p>无需再用模版代码，通过使用JavaScript编写的组件你可以更好地传递数据，将应用状态和DOM拆分开来。</p>\"}},{\"node\":{\"frontmatter\":{\"title\":\"一次学习，随处编写\"},\"html\":\"<p>无论你现在正在使用什么技术栈，你都可以随时引入 React 开发新特性。</p>\\n<p>React 也可以用作开发原生应用的框架 <a href=\\\"https://facebook.github.io/react-native/\\\">React Native</a>.</p>\"}}]}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/index.json\n// module id = 946\n// module chunks = 142629428675168"],"sourceRoot":""}